diff --git a/third-sem/CMakeLists.txt b/third-sem/CMakeLists.txt
index 2fb17ab..c6eb0ca 100644
--- a/third-sem/CMakeLists.txt
+++ b/third-sem/CMakeLists.txt
@@ -4,3 +4,4 @@ add_subdirectory(LW3)
 add_subdirectory(LW4)
 add_subdirectory(LW5)
 add_subdirectory(LW6)
+add_subdirectory(KR1-Romanov)
diff --git a/third-sem/KR1-Romanov/CMakeLists.txt b/third-sem/KR1-Romanov/CMakeLists.txt
new file mode 100644
index 0000000..ae0c98c
--- /dev/null
+++ b/third-sem/KR1-Romanov/CMakeLists.txt
@@ -0,0 +1,9 @@
+add_executable(KR1-Romanov
+        main.cpp
+        linked_list.tpp
+        linked_list.h
+        menu.cpp
+        menu.h
+        database.cpp
+        database.h
+)
diff --git a/third-sem/KR1-Romanov/database.cpp b/third-sem/KR1-Romanov/database.cpp
new file mode 100644
index 0000000..349c3d6
--- /dev/null
+++ b/third-sem/KR1-Romanov/database.cpp
@@ -0,0 +1,217 @@
+#include "database.h"
+
+#include <fstream>
+
+namespace db {
+
+    std::string format_status(const car_status &status) {
+        switch (status) {
+            case free:
+                return "свободна";
+            case has_order:
+                return "есть заказ";
+            case fulfilling_order:
+                return "исполняет заказ";
+            case in_repair:
+                return "в ремонте";
+            case MAX:
+                return "неизвестно";
+            default:
+                return "неизвестно";
+        }
+    }
+
+    std::string format_row(const car_row &car) {
+        std::ostringstream out{};
+        out
+                << car.car_type << ';'
+                << car.car_model << ';'
+                << car.car_plate << ';'
+                << car.car_capacity << ';'
+                << std::put_time(std::localtime(&car.next_inspection_date), "%d/%m/%Y") << ';'
+                << format_status(car.car_status) << ';'
+                << std::put_time(std::localtime(&car.next_inspection_date), "%d/%m/%Y");
+
+        return out.str();
+    }
+
+    int row_count(database *db) {
+        return db->_list.size();
+    }
+
+    void add_row(database *db, const car_row &new_row) {
+        db->_list.push_back(new_row); // copied inside
+    }
+
+#pragma region parsing
+
+    void print_err(size_t line_num, const std::string &reason) {
+        std::cerr << "Ошибка! Строка:" << std::setw(4) << line_num << ". " << reason << "\n";
+    }
+
+    bool check_fail(
+            std::istream &stream, size_t line_num,
+            const std::string &reason = "Недостаточно данных: преждевременно достигнут конец строки.") {
+        if (stream.fail()) {
+            std::cerr << '\n';
+            print_err(line_num, reason);
+            return true;
+        }
+        return false;
+    }
+
+    bool check_eof(
+            std::istream &stream, size_t line_num,
+            const std::string &reason = "Недостаточно данных: преждевременно достигнут конец строки.") {
+        if (stream.eof()) {
+            std::cerr << '\n';
+            print_err(line_num, reason);
+            return true;
+        }
+        return false;
+    }
+
+    void read_from_file(database *db, const std::filesystem::path &input_path) {
+        std::ifstream in_file(input_path);
+        int total_lines{}, parsed_lines{};
+        std::string line;
+        while (std::getline(in_file, line, '\n')) {
+            total_lines++;
+            std::cout << "──────────" << '\n';
+            // print the line without any changes
+            std::cout << "Строка" << std::setw(4) << total_lines << ": [" << line << "]\n";
+
+            car_row new_car;
+            std::istringstream line_stream(line);
+
+            std::getline(line_stream, new_car.car_type, ';');
+            if (check_fail(line_stream, total_lines,
+                           "Недостаточно данных: пустая строка.")) // no data, extracted nothing
+                continue;
+            std::cout << "Тип машины: [" << new_car.car_type << "] ";
+            if (check_eof(line_stream, total_lines)) // no more data, extracted something
+                continue;
+
+            std::getline(line_stream, new_car.car_model, ';');
+            if (check_fail(line_stream, total_lines)) // no more data, extracted nothing
+                continue;
+            std::cout << "Модель машины: [" << new_car.car_model << "] ";
+            if (check_eof(line_stream, total_lines)) // no more data, extracted something
+                continue;
+
+            std::getline(line_stream, new_car.car_plate, ';');
+            if (check_fail(line_stream, total_lines)) // no more data, extracted nothing
+                continue;
+            std::cout << "Номер машины: [" << new_car.car_plate << "] ";
+            if (check_eof(line_stream, total_lines)) // no more data, extracted something
+                continue;
+
+            std::getline(line_stream, new_car.car_capacity, ';');
+            if (check_fail(line_stream, total_lines)) // no more data, extracted nothing
+                continue;
+            std::cout << "Вместимость машины: [" << new_car.car_capacity << "] ";
+            if (check_eof(line_stream, total_lines)) // no more data, extracted something
+                continue;
+
+            line_stream >> new_car.next_inspection_date >> std::ws;
+            line_stream.ignore(1, ';');
+            if (check_fail(line_stream, total_lines)) // no more data, extracted nothing
+                continue;
+            std::cout << "Дата следующей инспекции: ["
+                      << std::put_time(std::localtime(&new_car.next_inspection_date), "%m/%d/%Y") << "] ";
+            if (check_eof(line_stream, total_lines)) // no more data, extracted something
+                continue;
+
+            int car_status;
+            line_stream >> car_status >> std::ws;
+            line_stream.ignore(1, ';');
+            new_car.car_status = static_cast<db::car_status>(car_status);
+            if (check_fail(line_stream, total_lines)) // no more data, extracted nothing
+                continue;
+            std::cout << "Состояние машины: [" << format_status(new_car.car_status) << "] ";
+            if (check_eof(line_stream, total_lines)) // no more data, extracted something
+                continue;
+
+            line_stream >> new_car.next_inspection_date >> std::ws;
+            line_stream.ignore(1, ';');
+            if (check_fail(line_stream, total_lines)) // no more data, extracted nothing
+                continue;
+            std::cout << "Дата заказа: [" << std::put_time(std::localtime(&new_car.next_inspection_date), "%m/%d/%Y")
+                      << "] ";
+            // ignoring trailing whitespace, try to get one more character to check for eof
+            (line_stream >> std::ws).get();
+
+
+            bool any_error = false;
+            if (!line_stream.eof()) { // non-empty input, BUT still more data
+                print_err(total_lines, "Избыток данных: не достигнут конец строки.");
+                any_error = true;
+            }
+            // next: validate actual data
+            if (car_status < 1 || car_status >= db::car_status::MAX) {
+                print_err(total_lines, "Некорректные данные: неверное состояние машины");
+                any_error = true;
+            }
+            if (any_error)
+                continue;
+
+            parsed_lines++;
+            add_row(db, new_car);
+        }
+        std::cout << "\nВсего строк в файле: " << total_lines << ". Успешно считано: " << parsed_lines << '\n';
+        if (parsed_lines < total_lines) {
+            std::cout << "Внимание! Некоторые строки были считаны неверно. "
+                         "Проверьте ошибки в выводе выше и исправьте данные\n";
+        }
+    }
+
+#pragma endregion // parsing
+
+    void print(database *db) {
+        auto current = db->_list.begin();
+        while (current != nullptr) {
+            std::cout << format_row(current->data);
+            current = current->next;
+        }
+    }
+
+    void save_to_file(database *db, const std::filesystem::path &output_path) {
+        std::ofstream out_file(output_path);
+        auto current = db->_list.begin();
+        while (current != nullptr) {
+            out_file
+                    << current->data.car_type << ';'
+                    << current->data.car_model << ';'
+                    << current->data.car_plate << ';'
+                    << current->data.car_capacity << ';'
+                    << current->data.next_inspection_date << ';'
+                    << current->data.car_status << ';'
+                    << current->data.order_date << '\n';
+            current = current->next;
+        }
+    }
+
+    void erase(database *db, int index) {
+        db->_list.erase(index);
+    }
+
+    void clear(database *db) {
+        db->_list.clear();
+    }
+
+    void sort(database *db, bool (*comp)(const db::car_row &, const db::car_row &)) {
+        auto *new_list = new llist::linked_list<car_row>;
+        while(!db->_list.empty()) {
+            auto current = db->_list.begin();
+            auto smallest = current;
+            while(current != nullptr) {
+                if(comp(current->data, smallest->data)) {
+                    smallest = current;
+                }
+                new_list->push_back(smallest->data);
+                db->_list.erase(smallest);
+            }
+        }
+    }
+
+} // db
\ No newline at end of file
diff --git a/third-sem/KR1-Romanov/database.h b/third-sem/KR1-Romanov/database.h
new file mode 100644
index 0000000..425857c
--- /dev/null
+++ b/third-sem/KR1-Romanov/database.h
@@ -0,0 +1,55 @@
+#ifndef LW_DATABASE_H
+#define LW_DATABASE_H
+
+#include "linked_list.h"
+
+#include <filesystem>
+
+namespace db {
+
+    enum car_status : int {
+        free             = 1,
+        has_order        = 2,
+        fulfilling_order = 3,
+        in_repair        = 4,
+        MAX,
+    };
+
+    std::string format_status(const car_status& status);
+
+    struct car_row {
+        std::string car_type;
+        std::string car_model;
+        std::string car_plate;
+        std::string car_capacity;
+        time_t next_inspection_date;
+        car_status car_status;
+        time_t order_date;
+    };
+
+    std::string format_row(const car_row& car);
+
+    struct database {
+        llist::linked_list<car_row> _list{};
+    };
+
+    int row_count(db::database *db);
+
+    // copies this row into the database
+    void add_row(db::database *db, const db::car_row &new_row);
+
+    void print(db::database *db);
+
+    void save_to_file(db::database *db, const std::filesystem::path& output_path);
+
+    void read_from_file(database *db, const std::filesystem::path& input_path);
+
+    void erase(database *db, int index);
+
+    void clear(database *db);
+
+    void sort(database *db, bool (*comp)(const db::car_row &, const db::car_row &));
+
+} // db
+
+#endif //LW_DATABASE_H
diff --git a/third-sem/KR1-Romanov/linked_list.h b/third-sem/KR1-Romanov/linked_list.h
new file mode 100644
index 0000000..3c21c3c
--- /dev/null
+++ b/third-sem/KR1-Romanov/linked_list.h
@@ -0,0 +1,61 @@
+#pragma clang diagnostic push
+#pragma ide diagnostic ignored "modernize-use-nodiscard"
+#ifndef LW_LINKED_LIST_H
+#define LW_LINKED_LIST_H
+
+#include <optional>
+#include <iostream>
+
+namespace llist {
+
+    template<class T>
+    class node {
+    public:
+        T data;
+        node *next;
+        node *prev;
+
+        explicit node(T newData);
+
+        node(T newData, node *newNext, node *newPrev);
+
+        ~node() = default;
+    };
+
+    template<class T>
+    class linked_list {
+    private:
+        llist::node<T> *head;
+        llist::node<T> *tail;
+        int _size;
+    public:
+        linked_list();
+
+        ~linked_list();
+
+        // node accessors
+        llist::node<T> *begin() const; // O(1)
+        llist::node<T> *end() const; // O(1)
+        llist::node<T> *nodeAt(int index) const; // O(n)
+        //capacity
+        bool empty() const; // O(1)
+        int size() const; // O(1)
+        //modifiers
+        void clear(); // O(n)
+        void insert(llist::node<T> *node, T data); // before node O(n)
+        void insert(int pos, T data); // before pos O(n)
+        void erase(llist::node<T> *node); // O(1)
+        void erase(int index); // O(n)
+        void push_back(const T& data); // O(1)
+        void pop_back(); //O(1)
+        void push_front(const T& data); // O(1)
+        void pop_front(); // O(1)
+    };
+
+} // llist
+
+#include "linked_list.tpp"
+
+#endif //LW_LINKED_LIST_H
+
+#pragma clang diagnostic pop
diff --git a/third-sem/KR1-Romanov/linked_list.tpp b/third-sem/KR1-Romanov/linked_list.tpp
new file mode 100644
index 0000000..382ebf1
--- /dev/null
+++ b/third-sem/KR1-Romanov/linked_list.tpp
@@ -0,0 +1,203 @@
+namespace llist {
+
+#pragma region node
+
+    template<class T>
+    llist::node<T>::node(T newData) {
+        data = newData;
+        next = nullptr;
+        prev = nullptr;
+    }
+
+    template<class T>
+    llist::node<T>::node(T newData, node *newNext, node *newPrev) {
+        data = newData;
+        next = newNext;
+        prev = newPrev;
+    }
+
+#pragma endregion
+
+#pragma region linked_list
+
+    template<class T>
+    llist::linked_list<T>::linked_list() : head{}, tail{}, _size{} {}
+
+    template<class T>
+    llist::linked_list<T>::~linked_list() {
+        llist::node<T> *current = head;
+        while (current != nullptr) {
+            llist::node<T> *next = current->next;
+            delete current;
+            current = next;
+        }
+    }
+
+    template<class T>
+    llist::node<T> *llist::linked_list<T>::begin() const { return head; }
+
+    template<class T>
+    llist::node<T> *llist::linked_list<T>::end() const { return tail; }
+
+    template<class T>
+    llist::node<T> *llist::linked_list<T>::nodeAt(int index) const {
+        llist::node<T> *current = head;
+        for (int i = 0; i < index; i++) {
+            if (current == nullptr)
+                return nullptr;
+            current = current->next;
+        }
+        return current;
+    }
+
+    template<class T>
+    bool llist::linked_list<T>::empty() const { return head == nullptr; }
+
+    template<class T>
+    int llist::linked_list<T>::size() const { return _size; }
+
+    template<class T>
+    void llist::linked_list<T>::clear() {
+        llist::node<T> *current = head;
+        // delete nodes until there's none left
+        while (current != nullptr) {
+            llist::node<T> *next = current->next;
+            delete current;
+            current = next;
+        }
+        head = nullptr;
+        tail = nullptr;
+        _size = 0;
+    }
+
+    template<class T>
+    void llist::linked_list<T>::insert(llist::node<T> *after_node, T data) {
+        if (after_node == nullptr) {
+            return;
+        }
+        // link the new node to its neighbors
+        llist::node<T> *new_node = new node(data, after_node, after_node->prev);
+        // link the prev node to the new node
+        if (after_node->prev != nullptr) {
+            after_node->prev->next = new_node;
+        }
+        // link the after node to the new node
+        after_node->prev = new_node;
+        if (after_node == head) {
+            head = new_node;
+        }
+        _size++;
+    }
+
+    template<class T>
+    void llist::linked_list<T>::insert(int pos, T data) {
+        if (pos == _size) {
+            push_back(data);
+        } else if (pos == 0) {
+            push_front(data);
+        } else {
+            insert(nodeAt(pos), data);
+        }
+    }
+
+    template<class T>
+    void llist::linked_list<T>::erase(llist::node<T> *node) {
+        if (node == nullptr) {
+            return;
+        }
+        // link the prev node to the next one
+        if (node->prev != nullptr) {
+            node->prev->next = node->next;
+        }
+        // link the next node to the prev one
+        if (node->next != nullptr) {
+            node->next->prev = node->prev;
+        }
+        // fix head
+        if (node == head) {
+            head = node->next;
+        }
+        // fix tail
+        if (node == tail) {
+            tail = node->prev;
+        }
+        delete node;
+        _size--;
+    }
+
+    template<class T>
+    void llist::linked_list<T>::erase(int index) {
+        erase(nodeAt(index));
+    }
+
+    template<class T>
+    void llist::linked_list<T>::push_back(const T &data) {
+        llist::node<T> *new_node = new node(data);
+        if (tail == nullptr) {
+            // empty
+            head = new_node;
+            tail = new_node;
+        } else {
+            // link tail node to ours
+            new_node->prev = tail;
+            // link our node to tail
+            tail->next = new_node;
+            // fix tail
+            tail = new_node;
+        }
+        _size++;
+    }
+
+    template<class T>
+    void llist::linked_list<T>::pop_back() {
+        if (tail == nullptr) { return; }
+        llist::node<T> *new_last = tail->prev;
+        delete tail;
+        tail = new_last;
+        if (tail == nullptr) {
+            // list is empty now, fix head
+            head = nullptr;
+        } else {
+            // unlink new tail
+            tail->next = nullptr;
+        }
+        _size--;
+    }
+
+    template<class T>
+    void llist::linked_list<T>::push_front(const T &data) {
+        llist::node<T> *new_node = new node(data);
+        if (head == nullptr) {
+            // empty
+            head = new_node;
+            tail = new_node;
+        } else {
+            // link head node to ours
+            new_node->next = head;
+            // link our node to head
+            head->prev = new_node;
+            // fix head
+            head = new_node;
+        }
+        _size++;
+    }
+
+    template<class T>
+    void llist::linked_list<T>::pop_front() {
+        if (head == nullptr) { return; }
+        llist::node<T> *new_first = head->next;
+        delete head;
+        head = new_first;
+        if (head == nullptr) {
+            // list is empty now, fix tail
+            tail = nullptr;
+        } else {
+            // unlink new head
+            head->prev = nullptr;
+        }
+    }
+
+
+#pragma endregion
+
+} // llist
diff --git a/third-sem/KR1-Romanov/main.cpp b/third-sem/KR1-Romanov/main.cpp
new file mode 100644
index 0000000..38d92dd
--- /dev/null
+++ b/third-sem/KR1-Romanov/main.cpp
@@ -0,0 +1,34 @@
+/******************************************************************
+*                     КАФЕДРА № 304 2 КУРС                        *
+*-----------------------------------------------------------------*
+* Project Type  : Win32 Console Application                       *
+* Project Name  : Database                                        *
+* File Name     : main.cpp                                        *
+* Language      : C/C++                                           *
+* Programmer(s) : Романов Д.И.                                    *
+* Modified By   :                                                 *
+* Created       : 01/12/2024                                      *
+* Last Revision : 15/12/2024                                      *
+* Comment(s)    : Линейные списки                                 *
+******************************************************************/
+
+#include <algorithm>
+#include <iostream>
+#include <random>
+#include <fstream>
+#include <filesystem>
+
+#include "menu.h"
+#include "database.h"
+
+int main() {
+    std::cout << "Курсовая Работа - Романов Денис Игоревич\n";
+    std::cout << "    Вариант №7\n";
+
+    auto *database = new db::database{};
+    std::cout << "Создана пустая база данных\n";
+
+    // main menu loop
+    menu::use_main_menu(database);
+    return 0;
+}
diff --git a/third-sem/KR1-Romanov/menu.cpp b/third-sem/KR1-Romanov/menu.cpp
new file mode 100644
index 0000000..b6dd74a
--- /dev/null
+++ b/third-sem/KR1-Romanov/menu.cpp
@@ -0,0 +1,276 @@
+#include "menu.h"
+
+#include "database.h"
+
+#include <iostream>
+#include <iomanip>
+#include <limits>
+#include <array>
+#include <filesystem>
+#include <fstream>
+
+typedef void (*menu_entry_function)(db::database *);
+
+namespace menu {
+    struct MenuEntry {
+        std::string name;
+        menu_entry_function function;
+    };
+
+    bool extract_date(const std::string& date_string, time_t& out_time) {
+        std::istringstream date_stream(date_string);
+        std::tm input_time = {};
+        date_stream >> std::get_time(&input_time, "%d/%m/%Y");
+        if(date_stream.fail()) {
+            return false;
+        }
+        input_time.tm_isdst = -1;
+        // normalize: 29/02/2013 would become 01/03/2013 (not a leap year)
+        std::tm normalized_time = input_time;
+        out_time = mktime(&normalized_time);
+        // validate (is the normalized date still the same?):
+        return (input_time.tm_mday == normalized_time.tm_mday &&
+                input_time.tm_mon == normalized_time.tm_mon &&
+                input_time.tm_year == normalized_time.tm_year);
+
+    }
+
+    // returns true if there is no delimeter in input
+    bool check_delimeter(const std::string& str) {
+        if(str.find(';') != std::string::npos) {
+            // found
+            return false;
+        }
+        return true;
+    }
+
+    void add_row_from_terminal(db::database *db) {
+        db::car_row car;
+        std::cout << "Введите тип машины\n> ";
+        std::getline(std::cin, car.car_type);
+        if(!check_delimeter(car.car_type)) {
+            std::cout << "Ввод не должен содержать знак ';'! Ничего не произошло\n";
+            return;
+        }
+        std::cout << "Введите модель машины\n> ";
+        std::getline(std::cin, car.car_model);
+        if(!check_delimeter(car.car_model)) {
+            std::cout << "Ввод не должен содержать знак ';'! Ничего не произошло\n";
+            return;
+        }
+        std::cout << "Введите номер машины\n> ";
+        std::getline(std::cin, car.car_plate);
+        if(!check_delimeter(car.car_plate)) {
+            std::cout << "Ввод не должен содержать знак ';'! Ничего не произошло\n";
+            return;
+        }
+        std::cout << "Введите пассажиро/грузоподъемность машины\n> ";
+        std::getline(std::cin, car.car_capacity);
+        if(!check_delimeter(car.car_capacity)) {
+            std::cout << "Ввод не должен содержать знак ';'! Ничего не произошло\n";
+            return;
+        }
+
+        std::cout << "Введите дату следующего техосмотра в формате dd/mm/yyyy\n> ";
+        std::string temp_date;
+        std::getline(std::cin, temp_date);
+        if(!extract_date(temp_date, car.next_inspection_date)) {
+            std::cout << "Введена некорректная дата. Ничего не произошло\n";
+            return;
+        }
+
+        std::cout << "Введите статус машины (1 - свободна, 2 - есть заказ, 3 - исполняет заказ, 4 - в ремонте)\n> ";
+        int car_status;
+        std::cin >> car_status;
+        if(car_status < 1 || car_status >= db::car_status::MAX) {
+            std::cout << "Неверный статус машины. Ничего не произошло\n";
+            return;
+        }
+        car.car_status = static_cast<db::car_status>(car_status);
+
+        std::cout << "Введите дату заказа в формате dd/mm/yyyy\n> ";
+        std::getline(std::cin, temp_date);
+        if(!extract_date(temp_date, car.order_date)) {
+            std::cout << "Введена некорректная дата. Ничего не произошло\n";
+            return;
+        }
+        std::cout << "Добавляем строку [" << db::format_row(car) << "] в базу данных\n";
+        db::add_row(db, car);
+    }
+
+    void add_rows_from_file(db::database *db) {
+        std::cout << "Введите путь до файла\n> ";
+        std::string file_path;
+        std::getline(std::cin, file_path, '\n');
+        if(file_path.empty()) {
+            std::cout << "Вы ввели пустой путь. Ничего не произошло\n";
+            return;
+        }
+
+        std::filesystem::path output_path = file_path;
+        if(!std::filesystem::exists(output_path)) {
+            std::cout << "Путь не существует. Ничего не произошло\n";
+            return;
+        }
+        std::cout << "Добавляем в базу строки из файла " << std::filesystem::absolute(output_path) << '\n';
+        db::read_from_file(db, output_path);
+    }
+
+    void print_to_terminal(db::database *db) {
+        db::print(db);
+    }
+
+    void save_to_file(db::database *db) {
+        std::cout << "Введите путь до файла\n> ";
+        std::string file_path;
+        std::getline(std::cin, file_path, '\n');
+        if(file_path.empty()) {
+            std::cout << "Вы ввели пустой путь. Ничего не произошло\n";
+            return;
+        }
+        std::filesystem::path output_path = file_path;
+        std::filesystem::create_directories(output_path.parent_path());
+        std::cout << "Сохраняем базу в файл " << std::filesystem::absolute(output_path) << '\n';
+        db::save_to_file(db, output_path);
+    }
+
+    void remove_one_row(db::database *db) {
+        std::cout << "Введите номер удаляемого элемента (его можно узнать, выведя базу на экран)\n> ";
+        int index;
+        std::cin >> index;
+        index--; // fix index
+        if(index < 0 || index >= db::row_count(db)) {
+            std::cout << "Такого номера в базе нет! Ничего не произошло\n";
+            return;
+        }
+        db::erase(db, index);
+    }
+
+    void remove_all_rows(db::database *db) {
+        std::cout << "Вы уверен, что хотите удалить всю базу из памяти? Проверьте, что она была сохранена на диск\n"
+                     "Для подтверждения введите 1\n> ";
+        int input;
+        std::cin >> input;
+        if(input != 1) {
+            std::cout << "Ничего не произошло\n";
+            return;
+        }
+        db::clear(db);
+    }
+
+    void sort_all_rows(db::database *db) {
+        std::cout << "Введите поле для сортировки (1 - тип, 2 - марка, 3 - номер, 4 - вместимость, 5 - дата следующего техосмотра, 6 - состояние, 7 - дата заказа)\n> ";
+        int sort_field;
+        std::cin >> sort_field;
+        typedef bool (*comp)(const db::car_row &, const db::car_row &);
+        comp comparison_function;
+        switch (sort_field) {
+            case 1: // type
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.car_type < b.car_type;
+                };
+            }
+                break;
+            case 2: // model
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.car_model < b.car_model;
+                };
+            }
+                break;
+            case 3: // plate
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.car_plate < b.car_plate;
+                };
+            }
+                break;
+            case 4: // capacity
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.car_capacity < b.car_capacity;
+                };
+            }
+                break;
+            case 5: // next_inspection_date
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.next_inspection_date < b.next_inspection_date;
+                };
+            }
+                break;
+            case 6: // status
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.car_status < b.car_status;
+                };
+            }
+                break;
+            case 7: // order_date
+            {
+                comparison_function = [](const db::car_row& a, const db::car_row& b) {
+                    return a.order_date < b.order_date;
+                };
+            }
+                break;
+            default:
+                std::cout << "Неверное поле для сортировки. Ничего не произошло\n";
+                break;
+        }
+        if(sort_field < 1 || sort_field > 7) {
+            std::cout << "Неверный статус машины. Ничего не произошло\n";
+            return;
+        }
+        db::sort(db, comparison_function);
+    }
+
+    void use_main_menu(db::database *db) {
+        static std::array<MenuEntry, 7> entries {{
+             {"добавить в базу одну строку из терминала", add_row_from_terminal},
+             {"добавить в базу все строки из файла", add_rows_from_file},
+             {"вывести базу на экран", print_to_terminal},
+             {"сохранить базу в файл", save_to_file},
+             {"удалить из базы одну строку", remove_one_row},
+             {"очистить базу из памяти", remove_all_rows},
+             {"отсортировать базу", sort_all_rows},
+//             {"найти строки", filter_rows},
+        }};
+
+        while (true) {
+            if(std::cin.fail()) { // couldn't parse the data into an int
+                std::cout << "Ошибка ввода. Ввод должен быть целым числом\n";
+                std::cin.clear();
+                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+                continue;
+            }
+
+            std::cout << "\nТекущий размер базы данных: " << db::row_count(db) << '\n';
+            std::cout << "Выберите операцию:\n";
+            std::cout << "-1) выйти из программы\n";
+            // print all possible operations
+            for (int i = 0; i < entries.size(); ++i) {
+                std::cout << i+1 << ") " << entries[i].name << '\n';
+            }
+            std::cout << "> ";
+
+            // 0 is also the default int value, so we can't put any operations on it. it'll get executed if parser fails
+            int option = 0;
+            std::cin >> option;
+
+            // exit out of the loop
+            if(option == -1) {
+                std::cout << "Выход...\n";
+                break;
+            }
+            option--; // fix index
+            if(option < 0 || option >= entries.size()) {
+                std::cout << "Неизвестная операция\n";
+                continue;
+            }
+            // call the function
+            entries[option].function(db);
+        }
+    }
+
+}; // menu
diff --git a/third-sem/KR1-Romanov/menu.h b/third-sem/KR1-Romanov/menu.h
new file mode 100644
index 0000000..799208c
--- /dev/null
+++ b/third-sem/KR1-Romanov/menu.h
@@ -0,0 +1,13 @@
+#ifndef LW_MENU_H
+#define LW_MENU_H
+
+#include "database.h"
+
+namespace menu {
+
+    void use_main_menu(db::database *db);
+
+
+} // menu
+
+#endif //LW_MENU_H
diff --git a/third-sem/KR1-Romanov/res/2.txt b/third-sem/KR1-Romanov/res/2.txt
new file mode 100644
index 0000000..a1bb701
--- /dev/null
+++ b/third-sem/KR1-Romanov/res/2.txt
@@ -0,0 +1,2 @@
+a;ab;abc;abcd;1704834000;4;1727730000
+у;к;е;н;978296400;1;1012597200
diff --git a/third-sem/KR1-Romanov/res/abc.txt b/third-sem/KR1-Romanov/res/abc.txt
new file mode 100644
index 0000000..3738c93
--- /dev/null
+++ b/third-sem/KR1-Romanov/res/abc.txt
@@ -0,0 +1 @@
+a;ab;abc;abcd;1704834000;4;1727730000
